# Giai đoạn 1: Nền tảng Python & Lập trình
## Bài 1.9: Đánh giá hiệu quả - Thuật toán và Độ phức tạp (Big O Notation)

### **🎯 Mục tiêu bài học:**
1.  Hiểu tại sao việc đo thời gian chạy tuyệt đối không phải là cách tốt để đánh giá thuật toán.
2.  Nắm vững khái niệm về **Độ phức tạp Thời gian** và ký hiệu **Big O**.
3.  Nhận biết và phân biệt các độ phức tạp phổ biến: $O(1)$, $O(\log n)$, $O(n)$, $O(n^2)$, v.v.
4.  Áp dụng Big O để phân tích hiệu năng của các đoạn code đơn giản.

---

### **1. Vấn đề: Tại sao không chỉ cần bấm giờ?**

Giả sử bạn có hai thuật toán sắp xếp. Bạn chạy cả hai trên máy tính và thấy thuật toán A mất 1 giây, thuật toán B mất 2 giây. Liệu có thể kết luận A tốt hơn B không?

**Câu trả lời là chưa chắc.** Thời gian chạy thực tế phụ thuộc vào quá nhiều yếu tố:
* **Phần cứng:** CPU, RAM, ổ cứng của máy tính.
* **Ngôn ngữ lập trình** và trình biên dịch.
* **Các chương trình khác** đang chạy trên hệ thống.
* **Kích thước của dữ liệu đầu vào.**

Chúng ta cần một phương pháp **khách quan**, độc lập với phần cứng để so sánh "hiệu quả" cốt lõi của các thuật toán. Phương pháp đó là đếm số lượng thao tác cơ bản mà thuật toán phải thực hiện.

---

### **2. Ký hiệu Big O (Big O Notation) ⏱️**

**Big O** là một ký hiệu toán học dùng để mô tả **hành vi tiệm cận** của một hàm khi đối số tiến tới vô cùng. Trong khoa học máy tính, nó mô tả **tốc độ tăng trưởng** của thời gian chạy (hoặc bộ nhớ sử dụng) khi **kích thước đầu vào (n) tăng lên**.

* Nó tập trung vào **trường hợp xấu nhất (worst-case)**.
* Nó bỏ qua các hằng số và các số hạng không chiếm ưu thế. Ví dụ, nếu một thuật toán thực hiện $3n^2 + 5n + 10$ thao tác, Big O của nó chỉ đơn giản là $O(n^2)$, vì khi `n` trở nên rất lớn, thành phần $n^2$ sẽ lấn át hoàn toàn các thành phần còn lại.

**Analogy:** Big O giống như việc mô tả mức tiêu thụ nhiên liệu của một chiếc xe. Bạn không quan tâm nó tốn bao nhiêu xăng để đi 1km đầu tiên. Bạn quan tâm đến mức tiêu thụ trung bình trên một quãng đường dài (ví dụ: "chiếc xe này ăn 5 lít/100km trên cao tốc"). Big O chính là "mức tiêu thụ trên cao tốc" của thuật toán.



---

### **3. Các Độ phức tạp Phổ biến**

Dưới đây là các độ phức tạp từ nhanh nhất đến chậm nhất:

* **$O(1)$ - Hằng số (Constant Time):** Thời gian chạy không phụ thuộc vào kích thước đầu vào `n`.
    * *Ví dụ:* Lấy một phần tử từ list bằng chỉ số (`my_list[5]`), lấy giá trị từ dictionary bằng key (`my_dict['key']`).

* **$O(\log n)$ - Logarit (Logarithmic Time):** Thời gian chạy tăng rất chậm khi `n` tăng. Thường xảy ra khi thuật toán loại bỏ một nửa dữ liệu ở mỗi bước.
    * *Ví dụ:* Tìm kiếm nhị phân (binary search) trong một danh sách đã được sắp xếp.

* **$O(n)$ - Tuyến tính (Linear Time):** Thời gian chạy tăng tuyến tính với `n`.
    * *Ví dụ:* Duyệt qua tất cả các phần tử của một list bằng một vòng lặp `for`.

* **$O(n \log n)$ - Tuyến tính-Logarit (Linearithmic Time):** Hiệu quả hơn $O(n^2)$.
    * *Ví dụ:* Các thuật toán sắp xếp hiệu quả như Merge Sort, Quick Sort.

* **$O(n^2)$ - Bậc hai (Quadratic Time):** Thời gian chạy tăng theo bình phương của `n`. Thường xảy ra với các vòng lặp lồng nhau.
    * *Ví dụ:* So sánh mọi cặp phần tử trong một list.

* **$O(2^n)$ - Hàm mũ (Exponential Time):** Cực kỳ chậm. Thời gian chạy tăng gấp đôi mỗi khi thêm một phần tử vào đầu vào. Thường không khả thi với `n` lớn (ví dụ: `n > 40`).
    * *Ví dụ:* Giải bài toán Tháp Hà Nội, tính Fibonacci bằng đệ quy thông thường.

---

### **4. Phân tích Độ phức tạp trên các Cấu trúc Dữ liệu**

Việc hiểu Big O giúp giải thích tại sao chúng ta lại chọn cấu trúc dữ liệu này thay vì cấu trúc dữ liệu khác.

| Thao tác                      | **List** | **Set / Dictionary** | Lý do                                                            |
|:------------------------------|:---------|:---------------------|:-----------------------------------------------------------------|
| Lấy phần tử (theo chỉ số/key) | $O(1)$   | $O(1)$               | Truy cập trực tiếp qua địa chỉ bộ nhớ/bảng băm.                  |
| Gán/Sửa phần tử               | $O(1)$   | $O(1)$               | Tương tự như trên.                                               |
| **Kiểm tra tồn tại (`in`)**   | $O(n)$   | **$O(1)$**           | List phải duyệt qua từng phần tử. Set/Dict dùng bảng băm.        |
| Thêm/Xóa phần tử              | $O(n)$*  | $O(1)$               | *Thêm/xóa ở đầu List tốn $O(n)$ vì phải dịch chuyển các phần tử. |

*Điểm khác biệt quan trọng nhất chính là thao tác `in`. Đây là lý do tại sao dùng `set` để kiểm tra sự tồn tại hoặc loại bỏ trùng lặp lại hiệu quả hơn `list` rất nhiều.*

---

### **✍️ Bài thực hành:**

Hãy phân tích và xác định độ phức tạp thời gian (Big O) cho các hàm sau. Giải thích tại sao bạn lại đưa ra câu trả lời đó.

1.  **Hàm `find_max`:**
    
        def find_max(numbers):
            max_value = numbers[0]
            for num in numbers:
                if num > max_value:
                    max_value = num
            return max_value

2.  **Hàm `has_duplicates`:**

        def has_duplicates(numbers):
            for i in range(len(numbers)):
                for j in range(i + 1, len(numbers)):
                    if numbers[i] == numbers[j]:
                        return True
            return False

3.  **Hàm `find_sum_target`:** (Tìm xem có 2 số trong list có tổng bằng `target` hay không)

        def find_sum_target(numbers, target):
            # Dùng set để kiểm tra sự tồn tại nhanh hơn
            seen_numbers = set()
            for num in numbers:
                complement = target - num
                if complement in seen_numbers:
                    return True
                seen_numbers.add(num)
            return False