# Giai đoạn 1: Nền tảng Python & Lập trình
## Bài 1.10: Các Thuật toán Sắp xếp & Tìm kiếm Kinh điển

### **🎯 Mục tiêu bài học:**
1.  Hiểu và triển khai các thuật toán tìm kiếm cơ bản: **Tìm kiếm Tuyến tính** và **Tìm kiếm Nhị phân**.
2.  Phân tích được sự đánh đổi về hiệu năng và điều kiện áp dụng của hai thuật toán trên.
3.  Hiểu cách hoạt động bên trong của một thuật toán sắp xếp đơn giản (**Sắp xếp Nổi bọt**) và một thuật toán hiệu quả (**Sắp xếp Trộn**).
4.  Củng cố kỹ năng phân tích độ phức tạp Big O thông qua các ví dụ thực tế.

---

### **1. Tìm kiếm (Searching)**

#### **a. Tìm kiếm Tuyến tính (Linear Search)**

* **Ý tưởng:** Đơn giản nhất có thể. Duyệt qua từng phần tử của danh sách từ đầu đến cuối, so sánh với giá trị cần tìm.
* **Độ phức tạp:** $O(n)$. Trong trường hợp xấu nhất, chúng ta phải duyệt qua toàn bộ danh sách.
* **Ưu điểm:** Cực kỳ đơn giản để triển khai và **không yêu cầu danh sách phải được sắp xếp**.

        def linear_search(data, target):
            """Tìm kiếm tuyến tính một giá trị trong danh sách."""
            for i in range(len(data)):
                if data[i] == target:
                    return i  # Trả về chỉ số nếu tìm thấy
            return -1 # Trả về -1 nếu không tìm thấy

        my_list = [4, 7, 1, 9, 3, 5]
        print(f"Linear Search: Vị trí của số 9 là {linear_search(my_list, 9)}")
        print(f"Linear Search: Vị trí của số 10 là {linear_search(my_list, 10)}")

#### **b. Tìm kiếm Nhị phân (Binary Search)**

* **Ý tưởng:** Một chiến lược "chia để trị" cực kỳ hiệu quả. Tại mỗi bước, ta so sánh giá trị cần tìm với phần tử ở giữa danh sách.
    * Nếu bằng, ta đã tìm thấy.
    * Nếu nhỏ hơn, ta loại bỏ nửa sau của danh sách.
    * Nếu lớn hơn, ta loại bỏ nửa trước của danh sách.
    Lặp lại quá trình này cho đến khi tìm thấy hoặc không còn gì để tìm.
* **Điều kiện bắt buộc:** Danh sách **PHẢI ĐƯỢC SẮP XẾP** trước.
* **Độ phức tạp:** $O(\log n)$. Mỗi bước chúng ta loại đi một nửa dữ liệu, do đó thời gian chạy tăng rất chậm. 

        def binary_search(sorted_data, target):
            """Tìm kiếm nhị phân một giá trị trong danh sách đã sắp xếp."""
            low = 0
            high = len(sorted_data) - 1

            while low <= high:
                mid = (low + high) // 2
                guess = sorted_data[mid]

                if guess == target:
                    return mid
                elif guess > target:
                    high = mid - 1
                else: # guess < target
                    low = mid + 1
            return -1

        my_sorted_list = [1, 3, 4, 5, 7, 9]
        print(f"\nBinary Search: Vị trí của số 9 là {binary_search(my_sorted_list, 9)}")
        print(f"Binary Search: Vị trí của số 10 là {binary_search(my_sorted_list, 10)}")

---

### **2. Sắp xếp (Sorting)**

#### **a. Sắp xếp Nổi bọt (Bubble Sort) - Ví dụ về $O(n^2)$**

* **Ý tưởng:** Lặp đi lặp lại việc duyệt qua danh sách, so sánh hai phần tử liền kề và đổi chỗ chúng nếu chúng sai thứ tự. Các phần tử lớn nhất sẽ từ từ "nổi" lên cuối danh sách giống như bọt khí.
* **Độ phức tạp:** $O(n^2)$. Đây là một thuật toán không hiệu quả và thường chỉ dùng cho mục đích giảng dạy.

        def bubble_sort(data):
            """Sắp xếp danh sách bằng thuật toán nổi bọt."""
            n = len(data)
            # Dùng hai vòng lặp lồng nhau
            for i in range(n):
                for j in range(0, n - i - 1):
                    if data[j] > data[j+1]:
                        # Đổi chỗ hai phần tử
                        data[j], data[j+1] = data[j+1], data[j]
            return data

        unsorted_list = [64, 34, 25, 12, 22, 11, 90]
        print(f"\nBubble Sort: Danh sách đã sắp xếp là {bubble_sort(unsorted_list.copy())}")

#### **b. Sắp xếp Trộn (Merge Sort) - Ví dụ về $O(n \log n)$**

* **Ý tưởng:** Một thuật toán "chia để trị" kinh điển.
    1.  **Chia (Divide):** Liên tục chia đôi danh sách cho đến khi mỗi danh sách con chỉ còn một phần tử (một danh sách có 1 phần tử được coi là đã sắp xếp).
    2.  **Trị (Conquer):** "Trộn" (merge) các danh sách con đã sắp xếp lại với nhau để tạo thành các danh sách lớn hơn và cũng được sắp xếp. Quá trình trộn được thực hiện một cách thông minh bằng cách so sánh phần tử đầu tiên của các danh sách con.
* **Độ phức tạp:** $O(n \log n)$. Cực kỳ hiệu quả và ổn định.

        def merge_sort(data):
            """Sắp xếp danh sách bằng thuật toán trộn."""
            if len(data) > 1:
                mid = len(data) // 2
                left_half = data[:mid]
                right_half = data[mid:]

                # Bước đệ quy để chia nhỏ
                merge_sort(left_half)
                merge_sort(right_half)

                # Bước trộn (merge)
                i = j = k = 0
                while i < len(left_half) and j < len(right_half):
                    if left_half[i] < right_half[j]:
                        data[k] = left_half[i]
                        i += 1
                    else:
                        data[k] = right_half[j]
                        j += 1
                    k += 1

                while i < len(left_half):
                    data[k] = left_half[i]
                    i += 1
                    k += 1

                while j < len(right_half):
                    data[k] = right_half[j]
                    j += 1
                    k += 1
            return data

        unsorted_list_2 = [38, 27, 43, 3, 9, 82, 10]
        print(f"Merge Sort: Danh sách đã sắp xếp là {merge_sort(unsorted_list_2.copy())}")


---

### **✍️ Bài thực hành:**

1.  **Thực hành Tìm kiếm nhị phân:**
    * Cho danh sách đã sắp xếp: `primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]`
    * Viết một chương trình nhỏ, không cần viết lại hàm, chỉ cần **mô phỏng lại bằng tay** các bước mà thuật toán Tìm kiếm nhị phân sẽ thực hiện để tìm số `13`.
    * In ra giá trị của `low`, `high`, `mid`, và `guess` ở mỗi bước lặp.

2.  **So sánh hiệu năng:**
    * Bài tập này không cần code, chỉ cần suy luận.
    * Giả sử bạn có một danh sách 1 triệu số chưa được sắp xếp.
    * **Tình huống A:** Bạn cần tìm một phần tử trong đó, và bạn chỉ tìm đúng 1 lần.
    * **Tình huống B:** Bạn cần tìm 1000 phần tử khác nhau trong đó.
    * Đối với mỗi tình huống, bạn sẽ chọn chiến lược nào?
        * **Chiến lược 1:** Dùng Tìm kiếm tuyến tính ($O(n)$) cho mỗi lần tìm.
        * **Chiến lược 2:** Sắp xếp danh sách trước ($O(n \log n)$), sau đó dùng Tìm kiếm nhị phân ($O(\log n)$) cho mỗi lần tìm.
    * Hãy giải thích lựa chọn của bạn dựa trên độ phức tạp Big O.