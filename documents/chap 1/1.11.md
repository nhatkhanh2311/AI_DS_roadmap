# Giai đoạn 1: Nền tảng Python & Lập trình
## Bài 1.11: Các Kỹ thuật và Tư duy Giải thuật Cốt lõi

### **🎯 Mục tiêu bài học:**
1.  Hiểu và nhận diện các mẫu tư duy giải thuật phổ biến: Vét cạn, Đệ quy, và Hai con trỏ.
2.  Biết cách triển khai các thuật toán đơn giản sử dụng các kỹ thuật này.
3.  Phân tích ưu, nhược điểm và độ phức tạp của từng cách tiếp cận.

---

### **1. Vét cạn (Brute-Force)**

Đây là cách tiếp cận thẳng thắn và đơn giản nhất: **thử tất cả các khả năng có thể** để tìm ra lời giải.

* **Tư duy:** "Làm thế nào để tôi kiểm tra mọi phương án?"
* **Ưu điểm:** Dễ suy nghĩ và triển khai. Thường là giải pháp đầu tiên bạn nghĩ đến.
* **Nhược điểm:** Thường không hiệu quả, có độ phức tạp cao (ví dụ: $O(n^2)$, $O(2^n)$).
* **Ví dụ:** Tìm một cặp số trong danh sách có tổng bằng `k`.

        def two_sum_brute_force(nums, k):
            """Tìm cặp số có tổng bằng k bằng phương pháp vét cạn."""
            n = len(nums)
            for i in range(n):
                for j in range(i + 1, n):
                    if nums[i] + nums[j] == k:
                        return (nums[i], nums[j])
            return None
    

    # Độ phức tạp của thuật toán này là O(n^2) do có 2 vòng lặp lồng nhau.

---

### **2. Đệ quy (Recursion) 🔄**

Đệ quy là một kỹ thuật trong đó một hàm tự gọi lại chính nó để giải quyết một phiên bản nhỏ hơn của cùng một vấn đề.

* **Tư duy:** "Làm thế nào tôi có thể giải quyết bài toán này nếu tôi đã biết cách giải một phiên bản nhỏ hơn của nó?"
* **Hai thành phần bắt buộc:**
    1.  **Trường hợp cơ sở (Base Case):** Một điều kiện dừng, là phiên bản đơn giản nhất của bài toán mà ta có thể giải ngay lập tức. Nếu không có nó, hàm sẽ chạy vô tận.
    2.  **Bước đệ quy (Recursive Step):** Hàm tự gọi lại chính nó với một đầu vào nhỏ hơn, tiến gần hơn đến trường hợp cơ sở.
* **Analogy:** Giống như búp bê Matryoshka của Nga, bên trong một con búp bê lớn là một con nhỏ hơn y hệt.

        def factorial(n):
            """Tính giai thừa của n bằng đệ quy."""
            # 1. Trường hợp cơ sở
            if n == 0:
                return 1
            # 2. Bước đệ quy
            else:
                return n * factorial(n - 1)

        print(f"5! = {factorial(5)}") # Output: 120

---

### **3. Hai con trỏ (Two Pointers)**

Đây là một kỹ thuật tối ưu hóa cực kỳ phổ biến, thường được sử dụng trên các **danh sách đã được sắp xếp** để giảm độ phức tạp từ $O(n^2)$ xuống $O(n)$.

* **Tư duy:** Sử dụng hai "con trỏ" (thực chất là các chỉ số `index`) để duyệt qua danh sách từ hai phía hoặc theo các hướng khác nhau.
* **Ví dụ:** Giải lại bài toán tìm cặp số có tổng bằng `k` trên một danh sách đã được sắp xếp.

        def two_sum_two_pointers(sorted_nums, k):
            """Tìm cặp số có tổng bằng k bằng phương pháp hai con trỏ."""
            left = 0
            right = len(sorted_nums) - 1

            while left < right:
                current_sum = sorted_nums[left] + sorted_nums[right]
                if current_sum == k:
                    return (sorted_nums[left], sorted_nums[right])
                elif current_sum < k:
                    # Tổng quá nhỏ, cần tăng số bên trái lên
                    left += 1
                else: # current_sum > k
                    # Tổng quá lớn, cần giảm số bên phải xuống
                    right -= 1
            return None

        # Độ phức tạp của thuật toán này là O(n) vì hai con trỏ chỉ đi qua danh sách một lần.
        my_sorted_list = [2, 7, 11, 15, 20]
        print(f"Cặp số có tổng bằng 22 là: {two_sum_two_pointers(my_sorted_list, 22)}") # Output: (2, 20)

---

### **✍️ Bài thực hành:**

1.  **Đảo ngược chuỗi bằng Đệ quy:**
    * Viết một hàm `reverse_string(s)` sử dụng đệ quy để đảo ngược một chuỗi `s`.
    * **Gợi ý:**
        * Trường hợp cơ sở: Nếu chuỗi rỗng hoặc chỉ có 1 ký tự, kết quả là gì?
        * Bước đệ quy: `reverse("hello")` có thể được giải quyết như thế nào nếu bạn đã có kết quả của `reverse("ello")`? (Kết quả là `reverse("ello")` + "h").

2.  **Kiểm tra chuỗi đối xứng (Palindrome) bằng Hai con trỏ:**
    * Một chuỗi đối xứng là chuỗi đọc xuôi hay ngược đều giống nhau (ví dụ: "madam", "racecar").
    * Viết một hàm `is_palindrome(s)` sử dụng kỹ thuật hai con trỏ (một bắt đầu từ đầu, một bắt đầu từ cuối và đi vào trong) để kiểm tra xem một chuỗi có phải là chuỗi đối xứng hay không. Hàm trả về `True` hoặc `False`.

3.  **Bình phương và Sắp xếp:**
    * Cho một danh sách các số nguyên **đã được sắp xếp** và có thể chứa số âm, ví dụ: `nums = [-4, -1, 0, 3, 10]`.
    * Viết một hàm `sorted_squares(nums)` trả về một danh sách mới chứa bình phương của mỗi số, và danh sách mới này cũng phải **được sắp xếp**.
    * **Cách 1 (Vét cạn/Đơn giản):** Bình phương tất cả các phần tử rồi gọi hàm `.sort()`. Phân tích độ phức tạp của cách này.
    * **Cách 2 (Tối ưu với Hai con trỏ):** Dùng hai con trỏ, một ở đầu và một ở cuối, để điền vào danh sách kết quả một cách hiệu quả trong một lần duyệt ($O(n)$). Hãy thử suy nghĩ về cách làm này.