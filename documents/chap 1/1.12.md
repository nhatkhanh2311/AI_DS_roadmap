# Giai đoạn 1: Nền tảng Python & Lập trình
## Bài 1.12: Nhập môn Quy hoạch động (Dynamic Programming - DP)

### **🎯 Mục tiêu bài học:**
1.  Hiểu được vấn đề cốt lõi mà Quy hoạch động giải quyết: **bài toán con gối nhau**.
2.  Nắm vững hai phương pháp tiếp cận chính của DP: **Top-down (Memoization)** và **Bottom-up (Tabulation)**.
3.  Áp dụng tư duy DP để giải quyết một bài toán kinh điển.

---

### **1. Vấn đề: Sự Bùng nổ của Đệ quy**

Hãy xem lại bài toán tính số Fibonacci thứ `n` bằng đệ quy thông thường:

    def fibonacci_recursive(n):
        if n <= 1:
            return n
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

Thuật toán này trông rất thanh lịch, nhưng nó cực kỳ không hiệu quả. Hãy xem cây các lời gọi hàm khi tính `fibonacci_recursive(5)`:



Bạn có thể thấy rằng `fib(3)` được tính 2 lần, `fib(2)` được tính 3 lần, v.v. Càng xuống sâu, số lần tính toán lặp lại càng nhiều. Đây được gọi là vấn đề **bài toán con gối nhau (Overlapping Subproblems)**. Độ phức tạp của thuật toán này là $O(2^n)$, cực kỳ tệ.

---

### **2. Quy hoạch động: "Đừng giải cùng một bài toán hai lần" 🤔**

Quy hoạch động (DP) là một kỹ thuật tối ưu hóa bằng cách **lưu lại kết quả của các bài toán con** để sử dụng lại sau này thay vì phải tính toán lại từ đầu.

Để một bài toán có thể giải được bằng DP, nó cần có hai thuộc tính:
1.  **Bài toán con gối nhau (Overlapping Subproblems):** Như ví dụ Fibonacci ở trên.
2.  **Cấu trúc con tối ưu (Optimal Substructure):** Lời giải tối ưu cho bài toán lớn có thể được xây dựng từ lời giải tối ưu của các bài toán con.

Có hai cách chính để triển khai DP:

---

### **3. Cách 1: Top-down với Ghi nhớ (Memoization)**

Đây là cách tiếp cận trực quan nhất. Chúng ta vẫn giữ nguyên cấu trúc đệ quy "từ trên xuống" (top-down) nhưng thêm vào một "bộ nhớ đệm" (cache), thường là một dictionary hoặc list, để lưu kết quả.

* **Logic:** Trước khi tính một bài toán con, hãy kiểm tra xem nó đã có trong cache chưa.
    * Nếu có, lấy kết quả ra dùng luôn.
    * Nếu chưa, hãy tính nó, **lưu vào cache**, rồi trả về kết quả.


    # Dùng một dictionary làm cache
    memo_cache = {}

    def fib_memoization(n):
        """Tính Fibonacci bằng đệ quy có ghi nhớ."""
        # Nếu kết quả đã có trong cache, trả về luôn
        if n in memo_cache:
            return memo_cache[n]
        
        # Nếu không, tính toán như bình thường
        if n <= 1:
            result = n
        else:
            result = fib_memoization(n-1) + fib_memoization(n-2)
        
        # Lưu kết quả vào cache trước khi trả về
        memo_cache[n] = result
        return result

    print(f"Fibonacci(50) dùng Memoization: {fib_memoization(50)}")

Với cách này, mỗi giá trị `fib(k)` chỉ được tính đúng một lần. Độ phức tạp giảm một cách đáng kinh ngạc từ $O(2^n)$ xuống còn $O(n)$.

---

### **4. Cách 2: Bottom-up với Bảng (Tabulation)**

Cách tiếp cận này loại bỏ hoàn toàn đệ quy. Chúng ta sẽ giải bài toán "từ dưới lên" (bottom-up), bắt đầu từ những bài toán con nhỏ nhất và xây dựng dần lên.

* **Logic:** Tạo một cái bảng (thường là một list/array) để lưu kết quả. Điền vào bảng tuần tự từ đầu đến cuối.


    def fib_tabulation(n):
        """Tính Fibonacci bằng phương pháp bảng."""
        if n <= 1:
            return n
        
        # Tạo một bảng để lưu các kết quả từ fib(0) đến fib(n)
        dp_table = [0] * (n + 1)
        dp_table[1] = 1
        
        # Tuần tự điền vào bảng
        for i in range(2, n + 1):
            dp_table[i] = dp_table[i-1] + dp_table[i-2]
            
        return dp_table[n]

    print(f"Fibonacci(50) dùng Tabulation: {fib_tabulation(50)}")

Cách này cũng có độ phức tạp là $O(n)$. Trong thực tế, nó thường nhanh hơn một chút so với Memoization vì không có chi phí cho các lời gọi hàm đệ quy.

---

### **✍️ Bài thực hành:**

**Bài toán "Leo cầu thang" (Climbing Stairs):**

Bạn đang leo một chiếc cầu thang có `n` bậc. Mỗi lần, bạn chỉ có thể leo `1` hoặc `2` bậc. Hỏi có tổng cộng bao nhiêu cách khác nhau để bạn có thể leo lên đến đỉnh?

* **Ví dụ:**
    * `n = 2`: có 2 cách (1+1, 2)
    * `n = 3`: có 3 cách (1+1+1, 1+2, 2+1)

**Yêu cầu:**

1.  **Tìm công thức truy hồi:** Hãy suy nghĩ xem số cách để leo lên bậc thứ `n` (`ways(n)`) có liên quan như thế nào đến `ways(n-1)` và `ways(n-2)`. Bạn sẽ thấy một sự tương đồng quen thuộc.
2.  Viết một hàm `climb_stairs(n)` để giải bài toán này bằng cả hai phương pháp: **Memoization** và **Tabulation**.