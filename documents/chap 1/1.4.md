# Giai đoạn 1: Nền tảng Python & Lập trình
## Bài 1.4: Cấu trúc dữ liệu Tuần tự - Lists & Tuples

### **🎯 Mục tiêu bài học:**
1.  Hiểu sâu hơn về các thao tác nâng cao trên **List**.
2.  Nắm vững khái niệm "bất biến" (immutability) của **Tuple** và các trường hợp sử dụng.
3.  Học cách viết List Comprehensions - một kỹ thuật mạnh mẽ và rất "Pythonic".
4.  Biết khi nào nên chọn List và khi nào nên chọn Tuple.

---

### **1. List: Đi sâu hơn 📜**

Chúng ta đã biết List có thứ tự và **có thể thay đổi (mutable)**. Hãy khám phá thêm một vài phương thức hữu ích.

    # Khởi tạo một list
    numbers = [1, 5, 2, 8, 4]

    # Sắp xếp list (thay đổi trực tiếp list gốc)
    numbers.sort()
    print(f"List sau khi sort(): {numbers}") # Output: [1, 2, 4, 5, 8]

    # Đảo ngược list (thay đổi trực tiếp list gốc)
    numbers.reverse()
    print(f"List sau khi reverse(): {numbers}") # Output: [8, 5, 4, 2, 1]

    # Chèn một phần tử vào vị trí cụ thể
    # insert(index, value)
    numbers.insert(2, 99) # Chèn số 99 vào vị trí có chỉ số 2
    print(f"List sau khi chèn: {numbers}") # Output: [8, 5, 99, 4, 2, 1]

#### **List Comprehensions: Một cách viết Pythonic**

List Comprehension là một cú pháp ngắn gọn và thanh lịch để tạo ra một list mới từ một list đã có.

    # Cách thông thường dùng vòng lặp for:
    squares = []
    for num in numbers:
        squares.append(num ** 2)
    print(f"Bình phương (cách thường): {squares}")

    # Cách dùng List Comprehension:
    # [biểu_thức for item in iterable]
    squares_comp = [num ** 2 for num in numbers]
    print(f"Bình phương (comprehension): {squares_comp}")

    # List Comprehension với điều kiện if:
    # Lấy bình phương của các số lẻ trong list
    odd_squares = [num ** 2 for num in numbers if num % 2 != 0]
    print(f"Bình phương số lẻ: {odd_squares}")

---

### **2. Tuple: Tại sao lại cần đến nó? 📦**

Chúng ta đã biết Tuple có thứ tự và **bất biến (immutable)**. Sự bất biến này chính là lý do tồn tại của nó.

* **Tại sao dùng Tuple?**
    1.  **Toàn vẹn dữ liệu:** Khi bạn có một bộ dữ liệu không bao giờ nên bị thay đổi (ví dụ: thông tin RGB của một màu, tên và kinh độ/vĩ độ của một thành phố), dùng Tuple sẽ đảm bảo nó không bị sửa đổi một cách vô tình.
    2.  **Làm key cho Dictionary:** Vì các key của dictionary phải là bất biến, bạn có thể dùng Tuple làm key, nhưng không thể dùng List.
    3.  **Hiệu suất:** Tuple chiếm ít bộ nhớ hơn và được truy cập nhanh hơn List một chút.

* **Named Tuples: Tuple "có tên"**
    Để code dễ đọc hơn, Python cung cấp `namedtuple`.

        from collections import namedtuple

        # Định nghĩa một "khuôn mẫu" cho Point
        Point = namedtuple("Point", ["x", "y", "z"])

        # Tạo một đối tượng từ khuôn mẫu
        p1 = Point(x=10, y=20, z=30)

        # Truy cập dữ liệu bằng tên, dễ đọc hơn nhiều so với chỉ số
        print(f"Tọa độ x của p1 là: {p1.x}") # Thay vì p1[0]
        print(f"Tọa độ z của p1 là: {p1.z}")

---

### **3. Khi nào dùng List, khi nào dùng Tuple?**

| Tình huống                                                       | Lựa chọn tốt nhất | Lý do                                                 |
|:-----------------------------------------------------------------|:------------------|:------------------------------------------------------|
| Bạn cần một danh sách sẽ thay đổi thường xuyên (thêm, xóa, sửa). | **List**          | Tính khả biến (mutable) là bắt buộc.                  |
| Dữ liệu của bạn đại diện cho một bản ghi cố định, không đổi.     | **Tuple**         | Tính bất biến (immutable) đảm bảo an toàn dữ liệu.    |
| Bạn cần trả về nhiều giá trị từ một hàm.                         | **Tuple**         | Cú pháp gọn gàng và đảm bảo kết quả không bị sửa đổi. |
| Bạn cần hiệu suất cao nhất có thể và dữ liệu không đổi.          | **Tuple**         | Nhanh hơn và nhẹ hơn một chút.                        |

---

### **✍️ Bài thực hành:**

1.  **Bình phương số chẵn:**
    * Cho một danh sách: `numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
    * Sử dụng **List Comprehension** để tạo ra một list mới chỉ chứa bình phương của các số chẵn từ danh sách trên.
    * Output mong đợi: `[4, 16, 36, 64, 100]`

2.  **Thông tin sinh viên:**
    * Viết một hàm `get_student_info()` trả về thông tin của một sinh viên dưới dạng một `tuple`: `("An", 22, "Hanoi")`.
    * Bên ngoài hàm, hãy gọi hàm này và sử dụng kỹ thuật "unpacking" để gán kết quả vào 3 biến riêng biệt: `name`, `age`, và `city`.
    * In 3 biến đó ra màn hình.

3.  **Quản lý màu sắc với Named Tuple:**
    * Import `namedtuple` từ thư viện `collections`.
    * Định nghĩa một `namedtuple` tên là `Color` với các trường là `R`, `G`, `B` (viết tắt cho Red, Green, Blue).
    * Tạo một đối tượng từ `Color` để biểu diễn màu Đỏ (`R=255, G=0, B=0`).
    * In ra giá trị `G` của đối tượng màu đó bằng cách truy cập qua tên (`.G`).