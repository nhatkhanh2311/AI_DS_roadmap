# Giai ƒëo·∫°n 2: N·ªÅn t·∫£ng To√°n & Th·ªëng k√™
## B√†i 2.1: ƒê·∫°i s·ªë tuy·∫øn t√≠nh (Ph·∫ßn 1) - Vector, Ma tr·∫≠n & NumPy

### **üéØ M·ª•c ti√™u b√†i h·ªçc:**
1.  Hi·ªÉu c√°c kh√°i ni·ªám c∆° b·∫£n: **Scalar, Vector, Ma tr·∫≠n** v√† c√°ch ch√∫ng bi·ªÉu di·ªÖn d·ªØ li·ªáu.
2.  L√†m quen v·ªõi **NumPy**, th∆∞ vi·ªán t√≠nh to√°n khoa h·ªçc n·ªÅn t·∫£ng c·ªßa Python.
3.  H·ªçc c√°ch t·∫°o v√† th·ª±c hi·ªán c√°c ph√©p to√°n c∆° b·∫£n tr√™n vector v√† ma tr·∫≠n b·∫±ng NumPy.

---

### **1. C√°c "Vi√™n g·∫°ch" X√¢y d·ª±ng D·ªØ li·ªáu**

Trong AI/ML, m·ªçi d·ªØ li·ªáu ƒë·ªÅu ƒë∆∞·ª£c chuy·ªÉn th√†nh s·ªë. ƒê·∫°i s·ªë tuy·∫øn t√≠nh cung c·∫•p c√°c ƒë·ªëi t∆∞·ª£ng ƒë·ªÉ ch·ª©a c√°c con s·ªë n√†y.

* **Scalar (V√¥ h∆∞·ªõng):** ƒê∆°n gi·∫£n l√† m·ªôt con s·ªë duy nh·∫•t.
    * *V√≠ d·ª•:* Tu·ªïi c·ªßa m·ªôt ng∆∞·ªùi (`25`), gi√° c·ªßa m·ªôt s·∫£n ph·∫©m (`50000`).

* **Vector:** L√† m·ªôt m·∫£ng 1 chi·ªÅu ch·ª©a c√°c con s·ªë, ƒë∆∞·ª£c s·∫Øp x·∫øp theo m·ªôt th·ª© t·ª± nh·∫•t ƒë·ªãnh. M·ªôt vector c√≥ hai thu·ªôc t√≠nh ch√≠nh l√† **h∆∞·ªõng (direction)** v√† **ƒë·ªô l·ªõn (magnitude)**.
    * *V√≠ d·ª•:* Bi·ªÉu di·ªÖn m·ªôt cƒÉn nh√† b·∫±ng c√°c ƒë·∫∑c tr∆∞ng: `[di·ªán_t√≠ch, s·ªë_ph√≤ng_ng·ªß, kho·∫£ng_c√°ch_ƒë·∫øn_trung_t√¢m]` -> `[100, 3, 5.5]`. ƒê√¢y l√† m·ªôt vector 3 chi·ªÅu.

* **Ma tr·∫≠n (Matrix):** L√† m·ªôt l∆∞·ªõi 2 chi·ªÅu ch·ª©a c√°c con s·ªë (m·ªôt t·∫≠p h·ª£p c√°c vector).
    * *V√≠ d·ª• 1:* M·ªôt b·ª©c ·∫£nh ƒëen tr·∫Øng c√≥ th·ªÉ ƒë∆∞·ª£c bi·ªÉu di·ªÖn d∆∞·ªõi d·∫°ng ma tr·∫≠n, m·ªói ph·∫ßn t·ª≠ l√† c∆∞·ªùng ƒë·ªô s√°ng c·ªßa m·ªôt pixel.
    * *V√≠ d·ª• 2:* M·ªôt b·ªô d·ªØ li·ªáu g·ªìm nhi·ªÅu cƒÉn nh√†, m·ªói h√†ng l√† m·ªôt vector ƒë·∫°i di·ªán cho m·ªôt cƒÉn nh√†.



---

### **2. Gi·ªõi thi·ªáu NumPy üî¢**

**NumPy (Numerical Python)** l√† th∆∞ vi·ªán c·ªët l√µi cho t√≠nh to√°n khoa h·ªçc trong Python. H·∫ßu nh∆∞ m·ªçi th∆∞ vi·ªán Khoa h·ªçc D·ªØ li·ªáu (Pandas, Scikit-learn, TensorFlow) ƒë·ªÅu ƒë∆∞·ª£c x√¢y d·ª±ng d·ª±a tr√™n NumPy.

* **ƒê·ªëi t∆∞·ª£ng ch√≠nh:** `ndarray` (n-dimensional array), m·ªôt c·∫•u tr√∫c d·ªØ li·ªáu m·∫°nh m·∫Ω ƒë·ªÉ l√†m vi·ªác v·ªõi c√°c m·∫£ng nhi·ªÅu chi·ªÅu.
* **T·∫°i sao ph·∫£i d√πng NumPy thay v√¨ List c·ªßa Python?**
    1.  **T·ªëc ƒë·ªô:** C√°c ph√©p to√°n c·ªßa NumPy ƒë∆∞·ª£c vi·∫øt b·∫±ng ng√¥n ng·ªØ C, nhanh h∆°n r·∫•t nhi·ªÅu so v·ªõi c√°c v√≤ng l·∫∑p Python th√¥ng th∆∞·ªùng.
    2.  **Ti·ªán l·ª£i:** Cung c·∫•p v√¥ s·ªë h√†m to√°n h·ªçc v√† ƒë·∫°i s·ªë tuy·∫øn t√≠nh ƒë∆∞·ª£c t·ªëi ∆∞u h√≥a.
    3.  **Ti·∫øt ki·ªám b·ªô nh·ªõ:** `ndarray` s·ª≠ d·ª•ng √≠t b·ªô nh·ªõ h∆°n List.

---

### **3. Th·ª±c h√†nh v·ªõi NumPy**

ƒê·∫ßu ti√™n, h√£y import th∆∞ vi·ªán. Quy ∆∞·ªõc chung l√† import n√≥ v·ªõi b√≠ danh `np`.

    import numpy as np

#### **a. T·∫°o Arrays**

    # T·∫°o t·ª´ m·ªôt Python list
    my_list = [1, 2, 3]
    my_vector = np.array(my_list)
    print(f"Vector: {my_vector}")

    my_nested_list = [[1, 2, 3], [4, 5, 6]]
    my_matrix = np.array(my_nested_list)
    print(f"Ma tr·∫≠n:\n{my_matrix}")

    # C√°c h√†m t·∫°o array ƒë·∫∑c bi·ªát
    zeros_vector = np.zeros(3) # Vector ch·ª©a 3 s·ªë 0
    ones_matrix = np.ones((2, 3)) # Ma tr·∫≠n 2x3 ch·ª©a to√†n s·ªë 1
    range_vector = np.arange(0, 10, 2) # Vector t·ª´ 0 ƒë·∫øn 9, b∆∞·ªõc nh·∫£y 2 -> [0 2 4 6 8]

#### **b. C√°c thu·ªôc t√≠nh quan tr·ªçng c·ªßa Array**

    print(f"\nH√¨nh d·∫°ng ma tr·∫≠n: {my_matrix.shape}") # Output: (2, 3) -> 2 h√†ng, 3 c·ªôt
    print(f"S·ªë chi·ªÅu: {my_matrix.ndim}") # Output: 2
    print(f"T·ªïng s·ªë ph·∫ßn t·ª≠: {my_matrix.size}") # Output: 6
    print(f"Ki·ªÉu d·ªØ li·ªáu: {my_matrix.dtype}") # Output: int64 (ho·∫∑c int32 t√πy h·ªá th·ªëng)

#### **c. C√°c ph√©p to√°n c∆° b·∫£n**

ƒê√¢y l√† n∆°i NumPy t·ªèa s√°ng. C√°c ph√©p to√°n ƒë∆∞·ª£c th·ª±c hi·ªán tr√™n **t·ª´ng ph·∫ßn t·ª≠ (element-wise)**.

    vec1 = np.array([1, 2, 3])
    vec2 = np.array([4, 5, 6])

    # Ph√©p c·ªông vector
    sum_vec = vec1 + vec2
    print(f"\nT·ªïng hai vector: {sum_vec}") # Output: [5 7 9]

    # Ph√©p nh√¢n v√¥ h∆∞·ªõng (scalar multiplication)
    scaled_vec = vec1 * 2
    print(f"Vector nh√¢n v·ªõi 2: {scaled_vec}") # Output: [2 4 6]
    
    # Ph√©p nh√¢n element-wise
    elementwise_product = vec1 * vec2
    print(f"T√≠ch element-wise: {elementwise_product}") # Output: [4 10 18]

#### **d. T√≠ch v√¥ h∆∞·ªõng (Dot Product)**

ƒê√¢y l√† m·ªôt trong nh·ªØng ph√©p to√°n quan tr·ªçng nh·∫•t, d√πng ƒë·ªÉ t√≠nh t·ªïng c√≥ tr·ªçng s·ªë.
C√¥ng th·ª©c: $a \cdot b = \sum_{i=1}^{n} a_i b_i$

    # C√°ch 1: D√πng h√†m np.dot()
    dot_product_1 = np.dot(vec1, vec2)
    
    # C√°ch 2: D√πng to√°n t·ª≠ @ (khuy·∫øn kh√≠ch t·ª´ Python 3.5+)
    dot_product_2 = vec1 @ vec2

    # (1*4) + (2*5) + (3*6) = 4 + 10 + 18 = 32
    print(f"\nT√≠ch v√¥ h∆∞·ªõng: {dot_product_1}") # Output: 32

---

### **‚úçÔ∏è B√†i th·ª±c h√†nh:**

1.  **T·∫°o v√† Kh√°m ph√°:**
    * T·∫°o m·ªôt ma tr·∫≠n `A` k√≠ch th∆∞·ªõc 3x4 ch·ª©a c√°c s·ªë t·ª´ 1 ƒë·∫øn 12. **G·ª£i √Ω:** d√πng `np.arange(1, 13)` r·ªìi `.reshape(3, 4)`.
    * In ra ma tr·∫≠n `A`.
    * In ra `shape`, `ndim`, v√† `size` c·ªßa ma tr·∫≠n `A`.

2.  **Ph√¢n t√≠ch Doanh s·ªë:**
    * Gi·∫£ s·ª≠ b·∫°n c√≥ doanh s·ªë (s·ªë l∆∞·ª£ng s·∫£n ph·∫©m b√°n ƒë∆∞·ª£c) c·ªßa 2 c·ª≠a h√†ng trong 1 tu·∫ßn, ƒë∆∞·ª£c bi·ªÉu di·ªÖn b·∫±ng 2 vector:
        `store1_sales = np.array([10, 20, 15, 25, 30])`
        `store2_sales = np.array([5, 22, 18, 20, 28])`
    * T√≠nh v√† in ra t·ªïng doanh s·ªë c·ªßa c·∫£ hai c·ª≠a h√†ng theo t·ª´ng ng√†y (ph√©p c·ªông vector).
    * C·ª≠a h√†ng 1 c√≥ ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i v√† d·ª± ki·∫øn doanh s·ªë tƒÉng 20%. H√£y t√≠nh doanh s·ªë m·ªõi c·ªßa c·ª≠a h√†ng 1 (nh√¢n vector v·ªõi m·ªôt scalar 1.2).

3.  **T√≠nh ti·ªÅn Gi·ªè h√†ng:**
    * B·∫°n c√≥ m·ªôt gi·ªè h√†ng v·ªõi s·ªë l∆∞·ª£ng c√°c m·∫∑t h√†ng: `quantities = np.array([2, 1, 5])` (2 b√°nh m√¨, 1 chai s·ªØa, 5 qu·∫£ tr·ª©ng).
    * Gi√° t∆∞∆°ng ·ª©ng c·ªßa m·ªói m·∫∑t h√†ng l√†: `prices = np.array([15000, 25000, 3000])`.
    * S·ª≠ d·ª•ng **t√≠ch v√¥ h∆∞·ªõng (dot product)** ƒë·ªÉ t√≠nh t·ªïng s·ªë ti·ªÅn c·ªßa gi·ªè h√†ng v√† in ra k·∫øt qu·∫£.