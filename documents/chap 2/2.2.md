# Giai ƒëo·∫°n 2: N·ªÅn t·∫£ng To√°n & Th·ªëng k√™
## B√†i 2.2: ƒê·∫°i s·ªë tuy·∫øn t√≠nh (Ph·∫ßn 2) - Ph√©p to√°n Ma tr·∫≠n & √ù nghƒ©a H√¨nh h·ªçc

### **üéØ M·ª•c ti√™u b√†i h·ªçc:**
1.  Hi·ªÉu quy t·∫Øc to√°n h·ªçc c·ªßa ph√©p **nh√¢n ma tr·∫≠n**.
2.  N·∫Øm b·∫Øt √Ω nghƒ©a c·ªët l√µi: m·ªôt ma tr·∫≠n l√† m·ªôt **ph√©p bi·∫øn ƒë·ªïi tuy·∫øn t√≠nh (linear transformation)**.
3.  Tr·ª±c quan h√≥a c√°ch m·ªôt ma tr·∫≠n c√≥ th·ªÉ **xoay, co gi√£n, v√† l√†m bi·∫øn d·∫°ng** kh√¥ng gian vector.
4.  L√†m quen v·ªõi c√°c ma tr·∫≠n ƒë·∫∑c bi·ªát: Ma tr·∫≠n ƒë∆°n v·ªã v√† Ma tr·∫≠n ngh·ªãch ƒë·∫£o.

---

### **1. Ph√©p nh√¢n Ma tr·∫≠n ho·∫°t ƒë·ªông nh∆∞ th·∫ø n√†o?**

ƒê√¢y l√† m·ªôt trong nh·ªØng ph√©p to√°n n·ªÅn t·∫£ng nh·∫•t trong to√†n b·ªô AI.

* **Quy t·∫Øc v·ªÅ K√≠ch th∆∞·ªõc:** ƒê·ªÉ nh√¢n ma tr·∫≠n `A` v·ªõi `B` (`A @ B`), s·ªë c·ªôt c·ªßa `A` ph·∫£i b·∫±ng s·ªë h√†ng c·ªßa `B`.
    * `(m, n) @ (n, p) -> (m, p)`
* **Quy t·∫Øc T√≠nh to√°n:** M·ªói ph·∫ßn t·ª≠ ·ªü v·ªã tr√≠ `(h√†ng i, c·ªôt j)` c·ªßa ma tr·∫≠n k·∫øt qu·∫£ l√† **t√≠ch v√¥ h∆∞·ªõng** c·ªßa `h√†ng i` c·ªßa ma tr·∫≠n ƒë·∫ßu ti√™n v√† `c·ªôt j` c·ªßa ma tr·∫≠n th·ª© hai.


    import numpy as np

    A = np.array([[1, 2], 
                  [3, 4]]) # Shape (2, 2)

    B = np.array([[5, 6], 
                  [7, 8]]) # Shape (2, 2)

    # Ph√©p nh√¢n ma tr·∫≠n (kh√°c v·ªõi ph√©p nh√¢n element-wise)
    C = A @ B 
    # C[0, 0] = (h√†ng 0 c·ªßa A) @ (c·ªôt 0 c·ªßa B) = (1*5 + 2*7) = 19
    # C[0, 1] = (h√†ng 0 c·ªßa A) @ (c·ªôt 1 c·ªßa B) = (1*6 + 2*8) = 22
    # C[1, 0] = (h√†ng 1 c·ªßa A) @ (c·ªôt 0 c·ªßa B) = (3*5 + 4*7) = 43
    # C[1, 1] = (h√†ng 1 c·ªßa A) @ (c·ªôt 1 c·ªßa B) = (3*6 + 4*8) = 50

    print("--- Ph√©p nh√¢n Ma tr·∫≠n ---")
    print(C)

* **L∆∞u √Ω:** Ph√©p nh√¢n ma tr·∫≠n **kh√¥ng c√≥ t√≠nh giao ho√°n**, t·ª©c l√† `A @ B` th∆∞·ªùng kh√¥ng b·∫±ng `B @ A`.

---

### **2. √ù nghƒ©a H√¨nh h·ªçc: Ma tr·∫≠n l√† m·ªôt Ph√©p bi·∫øn ƒë·ªïi üåå**

ƒê√¢y l√† √Ω t∆∞·ªüng c·ªët l√µi. H√£y ng·ª´ng xem ma tr·∫≠n l√† m·ªôt b·∫£ng s·ªë, m√† h√£y xem n√≥ nh∆∞ m·ªôt **h√†m s·ªë** ho·∫∑c m·ªôt **c·ªó m√°y**. C·ªó m√°y n√†y nh·∫≠n ƒë·∫ßu v√†o l√† m·ªôt vector v√† "bi·∫øn ƒë·ªïi" n√≥ th√†nh m·ªôt vector m·ªõi ·ªü m·ªôt v·ªã tr√≠ kh√°c.

`vector_moi = Ma_tran_bien_doi @ vector_goc`

C√°c ph√©p bi·∫øn ƒë·ªïi ph·ªï bi·∫øn trong kh√¥ng gian 2D:

* **Ma tr·∫≠n Co gi√£n (Scaling Matrix):** K√©o d√†i ho·∫∑c co ng·∫Øn vector.
    
        S = np.array([[2, 0], [0, 0.5]]) # G·∫•p ƒë√¥i chi·ªÅu x, gi·∫£m m·ªôt n·ª≠a chi·ªÅu y

* **Ma tr·∫≠n Bi·∫øn d·∫°ng tr∆∞·ª£t (Shearing Matrix):** L√†m "nghi√™ng" kh√¥ng gian.
    
        H = np.array([[1, 1], [0, 1]]) # K√©o nghi√™ng theo chi·ªÅu x

* **Ma tr·∫≠n Xoay (Rotation Matrix):** Xoay vector m·ªôt g√≥c `theta` ng∆∞·ª£c chi·ªÅu kim ƒë·ªìng h·ªì.
    
        theta = np.pi / 2 # G√≥c xoay 90 ƒë·ªô (pi/2 radians)
        c, s = np.cos(theta), np.sin(theta)
        R = np.array([[c, -s], [s, c]]) 

#### **Tr·ª±c quan h√≥a v·ªõi Matplotlib**

Ch√∫ng ta c√≥ th·ªÉ d√πng `matplotlib` ƒë·ªÉ v·∫Ω v√† xem c√°c ph√©p bi·∫øn ƒë·ªïi n√†y.

    import matplotlib.pyplot as plt

    v = np.array([1, 1]) # Vector g·ªëc

    # √Åp d·ª•ng c√°c ph√©p bi·∫øn ƒë·ªïi
    v_scaled = S @ v
    v_sheared = H @ v
    v_rotated = R @ v
    
    # ƒêo·∫°n code ƒë·ªÉ v·∫Ω (b·∫°n c√≥ th·ªÉ ch·∫°y th·ª≠)
    plt.figure(figsize=(6, 6))
    plt.quiver(0, 0, v[0], v[1], angles='xy', scale_units='xy', scale=1, color='blue', label='Vector g·ªëc [1, 1]')
    plt.quiver(0, 0, v_scaled[0], v_scaled[1], angles='xy', scale_units='xy', scale=1, color='red', label='Co gi√£n')
    plt.quiver(0, 0, v_sheared[0], v_sheared[1], angles='xy', scale_units='xy', scale=1, color='green', label='Bi·∫øn d·∫°ng')
    plt.quiver(0, 0, v_rotated[0], v_rotated[1], angles='xy', scale_units='xy', scale=1, color='purple', label='Xoay 90 ƒë·ªô')
    plt.xlim(-2, 3)
    plt.ylim(-2, 3)
    plt.grid()
    plt.legend()
    plt.title("Ma tr·∫≠n l√† c√°c Ph√©p bi·∫øn ƒë·ªïi Tuy·∫øn t√≠nh")
    plt.show()

---

### **3. C√°c Ma tr·∫≠n ƒê·∫∑c bi·ªát**

* **Ma tr·∫≠n ƒê∆°n v·ªã (Identity Matrix):** L√† ma tr·∫≠n vu√¥ng c√≥ s·ªë 1 tr√™n ƒë∆∞·ªùng ch√©o ch√≠nh v√† s·ªë 0 ·ªü c√°c v·ªã tr√≠ kh√°c. N√≥ gi·ªëng nh∆∞ s·ªë 1 trong ph√©p nh√¢n th√¥ng th∆∞·ªùng: b·∫•t k·ª≥ ma tr·∫≠n/vector n√†o nh√¢n v·ªõi n√≥ ƒë·ªÅu kh√¥ng ƒë·ªïi.

        I = np.eye(2) # T·∫°o ma tr·∫≠n ƒë∆°n v·ªã 2x2
        # [[1., 0.],
        #  [0., 1.]]
        print(f"\nMa tr·∫≠n ƒë∆°n v·ªã @ vector [3, 4] = {I @ np.array([3, 4])}")

* **Ma tr·∫≠n Ngh·ªãch ƒë·∫£o (Inverse Matrix):** Cho m·ªôt ma tr·∫≠n vu√¥ng `A`, ma tr·∫≠n ngh·ªãch ƒë·∫£o `A‚Åª¬π` l√† ma tr·∫≠n c√≥ th·ªÉ "ho√†n t√°c" l·∫°i ph√©p bi·∫øn ƒë·ªïi c·ªßa `A`.
    * `A‚Åª¬π @ A = I` (Ma tr·∫≠n ƒë∆°n v·ªã).
    * Kh√¥ng ph·∫£i ma tr·∫≠n n√†o c≈©ng c√≥ ngh·ªãch ƒë·∫£o.


        A = np.array([[1, 2], [3, 4]])
        A_inv = np.linalg.inv(A)

        # K·∫øt qu·∫£ s·∫Ω r·∫•t g·∫ßn v·ªõi ma tr·∫≠n ƒë∆°n v·ªã (do sai s·ªë t√≠nh to√°n)
        print(f"\nA‚Åª¬π @ A =\n{A_inv @ A}")

---

### **‚úçÔ∏è B√†i th·ª±c h√†nh:**

1.  **T√≠nh to√°n b·∫±ng tay v√† b·∫±ng m√°y:**
    * Cho hai ma tr·∫≠n: `X = [[1, 2], [3, 4]]` v√† `Y = [[2, 0], [1, 2]]`.
    * **B∆∞·ªõc 1:** T√≠nh `Z = X @ Y` **b·∫±ng tay** tr√™n gi·∫•y theo quy t·∫Øc ƒë√£ h·ªçc.
    * **B∆∞·ªõc 2:** D√πng NumPy ƒë·ªÉ t√≠nh l·∫°i v√† ki·ªÉm tra xem k·∫øt qu·∫£ c·ªßa b·∫°n c√≥ ƒë√∫ng kh√¥ng.

2.  **Tr·ª±c quan h√≥a Ph√©p bi·∫øn ƒë·ªïi:**
    * T·∫°o m·ªôt vector `v = np.array([2, 1])`.
    * T·∫°o m·ªôt ma tr·∫≠n `T` ƒë·ªÉ th·ª±c hi·ªán ƒë·ªìng th·ªùi 2 ph√©p bi·∫øn ƒë·ªïi sau:
        * L·∫≠t ng∆∞·ª£c vector qua tr·ª•c y (nh√¢n th√†nh ph·∫ßn x v·ªõi -1).
        * TƒÉng g·∫•p r∆∞·ª°i chi·ªÅu cao (nh√¢n th√†nh ph·∫ßn y v·ªõi 1.5).
    * **G·ª£i √Ω:** Ma tr·∫≠n `T` s·∫Ω l√† `[[-1, 0], [0, 1.5]]`.
    * D√πng `matplotlib` ƒë·ªÉ v·∫Ω vector `v` ban ƒë·∫ßu v√† vector `v_transformed = T @ v` sau khi bi·∫øn ƒë·ªïi tr√™n c√πng m·ªôt ƒë·ªì th·ªã.